#!/usr/bin/env bash

#######################################################
# Arbiter config
ARBITER_DIR=$(pwd)/.arbiter

# Ensure all docker commands ran in this script connect via arbiter's socket
export DOCKER_HOST=unix://${ARBITER_DIR}/docker.sock

################################################################################
#
# Main entry point to arbiter
#
################################################################################
function main(){
		if [[ $# < 1 ]] ; then
				echo "Usage: arbiter cmd [options]"
				exit 1
		fi

		CMD=$1

		case $CMD in
				"ls"*)
						echo "Doing ls"
						;;
				"connect"*)
						cmd_connect $2
						;;
				"disconnect"*)
						cmd_disconnect
						;;
				"docker"*)
						docker ${@:2}
						;;
				"pull"*)
						cmd_pull $2
						;;
				"clean"*)
						cmd_clean $2
						;;
				"treeploy"*)
						cmd_treeploy $2 $3
						;;
				*)
						log_fatal "Unknown command: ${CMD}"
						;;
		esac
}



################################################################################
#
# Command Functions
#
################################################################################



# Connects to a docker daemon potentially on a remote host by using
# ssh to forward a unix socket on the remote host to the local machine
#
# see: https://medium.com/@dperny/forwarding-the-docker-socket-over-ssh-e6567cfab160
function cmd_connect() {
		local HOST=$1

		if [[ -f ${ARBITER_DIR}/ssh.pid     ]] || \
			 [[ -e ${ARBITER_DIR}/docker.sock ]] || \
			 [[ -e ${ARBITER_DIR}/swarmhost   ]]
		then
				log_fatal "Either a connection is already open, or a previous one was not terminatted with 'arbiter disconect' - run that first"
		fi

		if [[ -z $HOST ]] ; then
				log_fatal "Expected host argument (can use 'localhost')"
				exit 1
		fi

		echo "Connecting to docker host: $1"



		mkdir -p ${ARBITER_DIR}

		echo ${HOST} > ${ARBITER_DIR}/swarmhost

		ssh -nNT -L ${ARBITER_DIR}/docker.sock:/var/run/docker.sock $1 &
		local SSH_PID=$!
		echo "Started ssh process: ${SSH_PID}"
		echo ${SSH_PID} > ${ARBITER_DIR}/ssh.pid
}

# Cleans up a connection previously opened by connect()
# Note that this can cleanup if the connection was incorrectly
# terminated (eg, machine was shutdown, and ARBITER_DIR is in
# inconsitent state, with files that point to a connection that
# was broken upon shutdown)
function cmd_disconnect() {
		if [[ -f ${ARBITER_DIR}/ssh.pid ]] ; then
				SSH_PID=$(cat $(pwd)/.arbiter/ssh.pid)

				echo "Killing SSH process: ${SSH_PID}"
				kill ${SSH_PID} > /dev/null 2>&1
		fi

		rm -f ${ARBITER_DIR}/docker.sock ${ARBITER_DIR}/swarmhost ${ARBITER_DIR}/ssh.pid
}

# Deletes data cached by arbiter for a stack
function cmd_clean() {
		local stack=$1

		if [[ -z $stack ]] ; then
				log_fatal "Expected <stack_name> argument"
		fi

		rm -rf ${ARBITER_DIR}/stacks/${stack}
}

# Pulls the git repo for some stack and checks out the version requiredd
# for deployment
function cmd_pull(){
		local stack=$1

		if [[ -z $stack ]] ; then
				log_fatal "Expected <stack_name> argument"
		fi

		if [[ ! -f $(pwd)/${stack}/REPOSITORY ]] ; then
				log_fatal "Stack '${stack}' is missing REPOSITORY file"
		fi
	  local repo=$(cat $(pwd)/${stack}/REPOSITORY)

		if [[ ! -f $(pwd)/${stack}/VERSION ]] ; then
				log_fatal "Stack '${stack}' is missing VERSION file"
		fi
		local version=$(cat $(pwd)/${stack}/VERSION)

		mkdir -p ${ARBITER_DIR}/stacks

		if [[ ! -d ${ARBITER_DIR}/stacks/${stack} ]] ; then
				git clone ${repo} ${ARBITER_DIR}/stacks/${stack}
		else
				CUR_REMOTE=$(cd ${ARBITER_DIR}/stacks/${stack} && git remote -v | grep origin | head -n 1 | awk '{ print $2 }')

				# Check that the remote is correct, readlink condition
				# is incase we are cloning a local git repo, and git has changed
				# the path to an absolute one
				if [[ ${CUR_REMOTE} != $repo ]] && \
					 [[ ! $(readlink ${repo}) == $(readlink ${CUR_REMOTE}) ]]
				then

						log_fatal "Checkout for ${stack} already exists with remote ${CUR_REMOTE}, but ${repo} was requested - try 'arbiter clean ${stack}'"

				fi

				(cd ${ARBITER_DIR}/stacks/${stack} && git fetch)
		fi

		if [[ $? != 0 ]] ; then
				log_fatal "Failed to update ${repo}"
		fi

		(cd ${ARBITER_DIR}/stacks/${stack} && git checkout ${version})

		if [[ $? != 0 ]] ; then
				log_fatal "Failed to checkout ${version}"
		fi
}

# Uses treeploy to deploy the appdata directory for a stack using all parameter
# files in the stack descriptor directory, as well as parameters.yaml in the
# directory from which arbiter is ran
function cmd_treeploy() {
		local stack=$1
		local target_path=$2

		if [[ -z $stack ]] || [[ -z ${target_path} ]] ; then
				log_fatal "Expected <stack> <target_path> arguments"
		fi



		local repo=$(cat $(pwd)/$stack/REPOSITORY)
		local version=$(cat $(pwd)/$stack/VERSION)

		if [[ ! -d ${ARBITER_DIR}/stacks/$stack ]] ; then
				cmd_pull $stack
		fi

		local swarmhost=$(cat ${ARBITER_DIR}/swarmhost)

		local cmd="treeploy ${ARBITER_DIR}/stacks/${stack}/appdata ${swarmhost}:${target_path} -vv --force"

		if [[ -f ./parameters.yaml ]] ; then
			 cmd="$cmd --modelfile ./parameters.yaml --targetdriver use_sudo true"
		fi

		for file in $(ls ${ARBITER_DIR}/stacks/${stack}/parameters/ | grep '.yaml$\|.yml$\|.json$') ; do
				cmd="$cmd --modelfile ${ARBITER_DIR}/stacks/${stack}/parameters/${file}"
		done

		exec $cmd
}



################################################################################
#
# Helper functions below
#
################################################################################
function log_fatal(){
		tput setaf 1
		>&2 printf "FATAL | "
		tput sgr0
		>&2 echo $1

		exit 1
}

function log_info(){
		tput setaf 6
		printf "INFO  | "
		tput sgr0
		echo $1
}

# We'd better actually run main...
# Right down at the bottom so that everything is in scope by the time we execute
main $@
